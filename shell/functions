#!/bin/bash

mcd(){
	mkdir -p "$1"
	cd "$1"
}

alarm(){
	termdown "$1" && cvlc ~/Music/christmas_music.mp3
}

exp(){
	cd ~/Code/expense_tracker
	python3 main.py "$@"
}

# Function to sync notes across platforms
ns(){
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        SCRIPT_PATH="$HOME/Code/dotfiles/sync_notes.sh"
        SHELL_CMD="bash"
    elif [[ -d ~/Documents ]]; then
        # a-shell on iPhone
        SCRIPT_PATH="~/Documents/dotfiles/sync_notes.sh"
        SHELL_CMD="sh"
    else
        echo "Unsupported environment"
        return 1
    fi

    if [[ -f "$SCRIPT_PATH" ]]; then
        "$SHELL_CMD" "$SCRIPT_PATH"
    else
        echo "Error: sync_notes.sh not found at $SCRIPT_PATH"
        return 1
    fi
}

alarm(){
cd ~/Documents && bash timer.sh $1 10
}

timer(){
    if [ -z "$1" ]; then
        # Show active timers
        echo "Active Timers:"
        echo "=============="
        local found_timers=false
        ps aux | grep -E "sleep [0-9]+" | grep -v grep | while read -r line; do
            found_timers=true
            local pid=$(echo "$line" | awk '{print $2}')
            local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf $i" "; print ""}')
            # Extract sleep duration in seconds
            local sleep_seconds=$(echo "$cmd" | grep -o "sleep [0-9]*" | awk '{print $2}')
            if [ -n "$sleep_seconds" ]; then
                # Get process start time
                local start_time=$(ps -o lstart= -p "$pid" 2>/dev/null)
                if [ -n "$start_time" ]; then
                    local start_epoch=$(date -j -f "%a %b %d %T %Y" "$start_time" "+%s" 2>/dev/null)
                    local current_epoch=$(date +%s)
                    local elapsed=$((current_epoch - start_epoch))
                    local remaining=$((sleep_seconds - elapsed))

                    if [ $remaining -gt 0 ]; then
                        local remaining_mins=$((remaining / 60))
                        local remaining_secs=$((remaining % 60))
                        local total_mins=$((sleep_seconds / 60))
                        echo "  PID: $pid - ${total_mins}min timer, ${remaining_mins}m ${remaining_secs}s remaining"
                    else
                        echo "  PID: $pid - Timer finishing..."
                    fi
                else
                    local minutes=$((sleep_seconds / 60))
                    echo "  PID: $pid - ${minutes} minute timer"
                fi
            fi
        done

        if [ "$found_timers" = false ]; then
            echo "  No active timers"
        fi

        echo ""
        echo "Help Documentation:"
        echo "=================="
        echo "Usage: timer <minutes>"
        echo ""
        echo "Description:"
        echo "  Starts a background timer that will notify you when complete."
        echo ""
        echo "Examples:"
        echo "  timer 5         # Start a 5 minute timer"
        echo "  timer 25        # Start a 25 minute timer (Pomodoro)"
        echo "  timer           # Show this help and active timers"
        echo ""
        echo "To cancel a timer:"
        echo "  kill <PID>      # Use the PID shown above"
        return 0
    fi
    local minutes=$1
    local seconds=$((minutes * 60))

    # Run timer in background
    (sleep $seconds && \
     osascript -e "display notification \"${minutes} minute timer finished!\" with title \"Timer\"" && \
     for i in {1..3}; do afplay /System/Library/Sounds/Glass.aiff; done) &

    local pid=$!
    echo "Timer started: ${minutes} minutes (${seconds}s)"
    echo "Running in background (PID: $pid)"
    echo "To cancel: kill $pid"
}

